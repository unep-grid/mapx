
#' Exacute expression in a forked process (unix only)
#' @param expr {expression} Expression to evaluate
#' @param export {list} Exported list of values used in expression
#' @param feedback {function} Function with one argument, 'res', to handle worker feedback. 'res'  is a list with two member : data and message. 
#' @param onMessage {function} Function with one argument, 'res', to handle worker messages. 'res' is a list with two member : time and message. This is produced by doForkMessage.
#' @param refreshRateSeconds {numeric} Number of second between read refresh
#' @param maxTimeSeconds {numeric} Maximum time for the process before ending. 
#' @message message to write
#' @n number of char in random id. Used internally
#' @return process pid
#' @export
doFork <- function(expr, export=NULL,onFeedback=NULL, onMessage=NULL, onTimeout=NULL, refreshRateSeconds= 1, maxTimeSeconds = Inf ){
  
  stopifnot(require(parallel))

  #
  # export function
  #
  export <- exprToFunction(export)

  #
  # do fork id. Used to create file of messages
  #
  id <- doForkMakeId()

  #
  # Get current time. Used to stop process if maxTimeSecond is set
  #
  start <- Sys.time()

  #
  # List in output
  # data = returned object
  # error = list of errors
  # message = messages
  #
  res <- list(
    data = NULL,
    error = NULL,
    message = NULL
    )

  #
  # File to hold messages
  #
  filePath <- file.path(tempdir(),sprintf("doFork_%s",id))   
  file.create(filePath)

  #
  # Function to be evalutad in another process  
  #
  jobFun <- shiny:::exprToFunction({

    session <- getDefaultReactiveDomain()
    input <- session$input
    file <- filePath 

    expr

  },env=sys.frame(-1))

  #
  # Create a forked process with the function
  #
  job <- mcparallel({
    jobFun()
  })

  #
  # Internal observer. Triggered by invalidateLater function
  #
  observe({
    tryCatch(
      error = function(c){
        #
        # Kill process after an error
        #
        tools::pskill(job$pid)

        #
        # Use stop and display message
        #
        stop(c$message)
      },
      expr={

        #
        # init message list
        #
        msg <- list(
          id = sprintf("doFork_%s",job$pid)
          )

        #
        # Get elapsed time since the begining
        #
        elapsed <- as.numeric(
          Sys.time() - start,
          units="secs"
          )

        #
        # Evalate timeout
        #
        if( isTRUE( elapsed > maxTimeSeconds ) ){

          res$timeout <- sprintf(
            "Timeout. Process took more than %s [s]"
            , maxTimeSeconds
            )
        }else{
          #
          # Retrieve result. We don't know if it's done yet.
          #
          res$data <- mccollect(
            jobs = job, 
            wait = F
            )[[1]]
        }

        #
        # Read message if any.
        # Text generated by doForkMessage.
        #
        tryCatch({

          m <- readLines(filePath)

          if(length(m)>0 && !is.null(m) && !is.na(m)){

            #
            # Extract json messge
            #
            m <- jsonlite::fromJSON(m)
            msg <- c( msg , m )

            #
            # Use result in onMessage function
            #
            onMessage( msg )

          }
        },error=function(c){

          #
          # If error during message reading, return a warning
          #
          warning(c$message)

        })

        #
        # Result evaluation
        #
        if(all(sapply(res,is.null))){

          #
          # if all res are mull, trigger invalidate later
          #
          invalidateLater( millis = refreshRateSeconds*1000 )

        }else{

          #
          # If try-error in res$data, rewrite error in error member
          #
          if(class(res$data)=="try-error"){
            res$error <- as.character(res$data)
          }

          #
          # If error member
          #
          if( !is.null( res$error )){
            stopApp()
            stop( res$error )
          }

          #
          # Kill process if needed
          #
          tools::pskill( job$pid )

          #
          # Use onFeedback function on the result set
          # 
          onFeedback( res )
        }

      })

  })

  #
  # As soon as the doFork is done, return the job id. 
  #
  return(job$pid)
}

#' @describeIn doFork Create doFork random id
doForkMakeId <- function(n=5){
  paste0(letters[ceiling(runif(n)*26)],collapse="")
}

#' @describeIn doFork Write a message in file during forked process
doForkMessage <- function(message=NULL){

  if( is.null(message) || !is.list(message)) return()

  e <- parent.frame()

  m <- jsonlite:::toJSON(message)

  write(m,e$file)

}


